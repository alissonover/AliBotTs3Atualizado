import { TeamSpeak } from "ts3-nodejs-library";
import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';

interface BotClientConfig {
  host: string;
  serverport: number;
  queryport: number;
  username: string;
  password: string;
  nickname: string;
  protocol: "raw" | "ssh";
  channelId?: string;
}

interface ClaimedTimer {
  userId: string;
  userName: string;
  codigo: string;
  nomeRespawn: string;
  tier: string;
  tempoRestante: number; // em minutos
  intervalId: NodeJS.Timeout;
  iniciadoEm: number; // timestamp quando foi criado
}

interface TimerPersistencia {
  userId: string;
  userName: string;
  codigo: string;
  nomeRespawn: string;
  tier: string;
  tempoRestante: number;
  iniciadoEm: number;
}

interface NextQueue {
  userId: string;
  userName: string;
  codigo: string;
  tempoDesejado: number; // em minutos
  adicionadoEm: number; // timestamp
}

interface NextTimeout {
  userId: string;
  userName: string;
  codigo: string;
  tempoDesejado: number;
  timeoutId: NodeJS.Timeout;
  expiraEm: number; // timestamp quando expira
}

interface QueuePersistencia {
  filas: NextQueue[];
  timeouts: Omit<NextTimeout, 'timeoutId'>[];
}

interface RespawnInfo {
  nome: string;
  tier: string;
}

class TS3ClientBot {
  private teamspeak: TeamSpeak | null = null;
  private config: BotClientConfig;
  private botClientId: string | null = null;
  private timers: Map<string, ClaimedTimer> = new Map(); // key: userId-codigo
  private timersFilePath: string;
  private nextQueues: Map<string, NextQueue[]> = new Map(); // key: codigo, value: array de usuarios na fila
  private nextTimeouts: Map<string, NextTimeout> = new Map(); // key: userId-codigo, value: timeout ativo
  private queueFilePath: string;
  private tentandoReconectar: boolean = false; // Flag para evitar reconexÃµes simultÃ¢neas
  private ultimaAtualizacaoTibia: number = 0; // Cache para API do Tibia
  private membrosOnlineTibia: any[] = []; // Cache dos membros online
  private tibiaCacheFilePath: string; // Caminho do arquivo de cache da API Tibia
  private atualizandoTibia: boolean = false; // Flag para evitar requisiÃ§Ãµes simultÃ¢neas
  
  // Mapa de cÃ³digos para informaÃ§Ãµes de respawn
  private respawns: Map<string, RespawnInfo> = new Map([
    ['f4', { nome: 'Cobra Castelo', tier: 'Tier 1' }],
    ['a1', { nome: 'DragÃ£o Vermelho', tier: 'Tier 2' }],
    ['b3', { nome: 'Lich Supremo', tier: 'Tier 3' }],
    ['x7', { nome: 'DemÃ´nio AnciÃ£o', tier: 'Tier 4' }],
    ['c2', { nome: 'Orc Warlord', tier: 'Tier 1' }],
    ['d5', { nome: 'Hydra AnciÃ£', tier: 'Tier 2' }],
    ['e8', { nome: 'Necromante Negro', tier: 'Tier 3' }],
    ['g1', { nome: 'Titan de Ferro', tier: 'Tier 4' }]
  ]);

  constructor(config: BotClientConfig) {
    this.config = config;
    this.timersFilePath = path.join(__dirname, '..', 'timers-backup.json');
    this.queueFilePath = path.join(__dirname, '..', 'queue-backup.json');
    this.tibiaCacheFilePath = path.join(__dirname, '..', 'tibia-cache.json');
  }

  // Imagem permanente que aparece no topo do canal Claimeds
  private readonly imagemClaimeds = `[img]https://i.imgur.com/qzjiLZT.png[/img]

ğŸ¯ **SISTEMA DE CLAIMEDS - ALIBOT** ğŸ¯
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš”ï¸ **Respawns** âš”ï¸
ğŸ“‹ Use: [b]!resp [cÃ³digo] [tempo][/b] Entrar/Aceitar o claimed
ğŸšª Use: [b]!leave [cÃ³digo][/b] - Sair Fila/Respawn
ğŸ“ Use: [b]!next [cÃ³digo] [tempo][/b] - Entrar na fila
ğŸ“Š Use: [b]!respinfo [cÃ³digo][/b] - Ver fila do respawn

ğŸ¤¡ Exemplo de uso com tempo: !resp f4 00:30 (horas:minutos)
    ps: Caso nÃ£o adicione valor ao tempo, serÃ¡ considerado 2 horas e 30 minutos.


â° Claimeds abaixo:

`;

  // MÃ©todo para obter descriÃ§Ã£o base com imagem
  private obterDescricaoBaseClaimeds(): string {
    return this.imagemClaimeds;
  }

  // MÃ©todo para inicializar canal Claimeds com imagem permanente
  private async inicializarCanalClaimeds(): Promise<void> {
    if (!this.teamspeak) return;

    try {
      const claimedChannelId = "2";
      
      // Verificar se o canal jÃ¡ tem a imagem
      const channelInfo = await this.teamspeak.channelInfo(claimedChannelId);
      let descricaoAtual = channelInfo.channelDescription || "";
      
      // Se nÃ£o tem a imagem ou estÃ¡ vazio, inicializar
      if (!descricaoAtual.includes('ğŸ¯ **SISTEMA DE CLAIMEDS** ğŸ¯')) {
        const descricaoInicial = this.obterDescricaoBaseClaimeds();
        
        await this.teamspeak.channelEdit(claimedChannelId, {
          channelDescription: descricaoInicial
        });
        
        console.log("ğŸ–¼ï¸ Canal Claimeds inicializado com imagem permanente");
      } else {
        console.log("âœ… Canal Claimeds jÃ¡ possui imagem permanente");
      }
      
    } catch (error: any) {
      console.error("âŒ Erro ao inicializar canal Claimeds:", error.msg || error.message);
    }
  }

  // MÃ©todo para salvar filas em arquivo JSON
  private salvarFilas(): void {
    try {
      const filasParaSalvar: NextQueue[] = [];
      const timeoutsParaSalvar: Omit<NextTimeout, 'timeoutId'>[] = [];
      
      // Salvar todas as filas
      this.nextQueues.forEach((fila, codigo) => {
        fila.forEach(item => {
          filasParaSalvar.push(item);
        });
      });

      // Salvar timeouts ativos
      this.nextTimeouts.forEach((timeout) => {
        timeoutsParaSalvar.push({
          userId: timeout.userId,
          userName: timeout.userName,
          codigo: timeout.codigo,
          tempoDesejado: timeout.tempoDesejado,
          expiraEm: timeout.expiraEm
        });
      });

      const dadosParaSalvar: QueuePersistencia = {
        filas: filasParaSalvar,
        timeouts: timeoutsParaSalvar
      };

      fs.writeFileSync(this.queueFilePath, JSON.stringify(dadosParaSalvar, null, 2));
      console.log(`ğŸ’¾ Filas salvas: ${filasParaSalvar.length} itens na fila, ${timeoutsParaSalvar.length} timeouts ativos`);
    } catch (error) {
      console.error("âŒ Erro ao salvar filas:", error);
    }
  }

  // MÃ©todo para carregar filas do arquivo JSON
  private async carregarFilas(): Promise<void> {
    try {
      if (!fs.existsSync(this.queueFilePath)) {
        console.log("ğŸ“‚ Nenhum arquivo de backup de filas encontrado");
        return;
      }

      const dados = fs.readFileSync(this.queueFilePath, 'utf8');
      const dadosSalvos: QueuePersistencia = JSON.parse(dados);
      
      if (!dadosSalvos.filas && !dadosSalvos.timeouts) {
        console.log("ğŸ“‚ Nenhuma fila salva para recuperar");
        return;
      }

      console.log(`ğŸ”„ Recuperando ${dadosSalvos.filas?.length || 0} itens de fila e ${dadosSalvos.timeouts?.length || 0} timeouts...`);
      
      // Recriar filas
      if (dadosSalvos.filas) {
        for (const item of dadosSalvos.filas) {
          if (!this.nextQueues.has(item.codigo)) {
            this.nextQueues.set(item.codigo, []);
          }
          this.nextQueues.get(item.codigo)!.push(item);
        }
      }

      // Recriar timeouts ativos
      const agora = Date.now();
      if (dadosSalvos.timeouts) {
        for (const timeoutData of dadosSalvos.timeouts) {
          if (timeoutData.expiraEm > agora) {
            // Timeout ainda vÃ¡lido, recriar
            await this.criarTimeoutNext(timeoutData.userName, timeoutData.codigo, timeoutData.userId, timeoutData.tempoDesejado, timeoutData.expiraEm - agora);
          } else {
            // Timeout expirou, remover da fila automaticamente
            console.log(`â° Timeout de ${timeoutData.userName} (${timeoutData.codigo}) expirou durante desconexÃ£o`);
            await this.removerDaFilaNext(timeoutData.userName, timeoutData.codigo, timeoutData.userId);
          }
        }
      }

      // Limpar arquivo apÃ³s recuperaÃ§Ã£o
      fs.unlinkSync(this.queueFilePath);
      console.log("ğŸ—‘ï¸ Arquivo de backup de filas limpo apÃ³s recuperaÃ§Ã£o");

    } catch (error) {
      console.error("âŒ Erro ao carregar filas:", error);
    }
  }

  // MÃ©todo para salvar timers em arquivo JSON
  private salvarTimers(): void {
    try {
      const timersParaSalvar: TimerPersistencia[] = [];
      
      this.timers.forEach((timer) => {
        timersParaSalvar.push({
          userId: timer.userId,
          userName: timer.userName,
          codigo: timer.codigo,
          nomeRespawn: timer.nomeRespawn,
          tier: timer.tier,
          tempoRestante: timer.tempoRestante,
          iniciadoEm: timer.iniciadoEm
        });
      });

      fs.writeFileSync(this.timersFilePath, JSON.stringify(timersParaSalvar, null, 2));
      console.log(`ğŸ’¾ Timers salvos: ${timersParaSalvar.length} ativos`);
    } catch (error) {
      console.error("âŒ Erro ao salvar timers:", error);
    }
  }

  // MÃ©todo para carregar timers do arquivo JSON
  private async carregarTimers(): Promise<void> {
    try {
      if (!fs.existsSync(this.timersFilePath)) {
        console.log("ğŸ“‚ Nenhum arquivo de backup de timers encontrado");
        return;
      }

      const dados = fs.readFileSync(this.timersFilePath, 'utf8');
      const timersSalvos: TimerPersistencia[] = JSON.parse(dados);
      
      if (timersSalvos.length === 0) {
        console.log("ğŸ“‚ Nenhum timer salvo para recuperar");
        return;
      }

      console.log(`ğŸ”„ Recuperando ${timersSalvos.length} timers salvos...`);
      
      const agora = Date.now();
      
      for (const timerSalvo of timersSalvos) {
        // Calcular tempo decorrido desde que foi salvo
        const tempoDecorrido = Math.floor((agora - timerSalvo.iniciadoEm) / (1000 * 60)); // em minutos
        const tempoRestanteAtual = timerSalvo.tempoRestante - tempoDecorrido;
        
        if (tempoRestanteAtual <= 0) {
          // Timer expirou enquanto bot estava offline
          console.log(`â° Timer de ${timerSalvo.userName} (${timerSalvo.codigo}) expirou durante desconexÃ£o`);
          await this.removerClaimedAutomatico(timerSalvo.userName, timerSalvo.codigo, timerSalvo.userId);
          continue;
        }

        // Recriar timer com tempo atualizado
        await this.recriarTimer(
          timerSalvo.userName, 
          timerSalvo.codigo, 
          timerSalvo.userId, 
          tempoRestanteAtual, 
          timerSalvo.iniciadoEm
        );
        
        console.log(`âœ… Timer restaurado: ${timerSalvo.userName} (${timerSalvo.codigo}) - ${tempoRestanteAtual} min restantes`);
      }

      // Limpar arquivo apÃ³s recuperaÃ§Ã£o
      fs.unlinkSync(this.timersFilePath);
      console.log("ğŸ—‘ï¸ Arquivo de backup limpo apÃ³s recuperaÃ§Ã£o");

      // Atualizar canal com todos os timers recuperados
      if (this.timers.size > 0) {
        await this.atualizarTodosTimersNoCanal();
        console.log(`ğŸ”„ Canal Claimeds atualizado com ${this.timers.size} timers restaurados`);
      }

    } catch (error) {
      console.error("âŒ Erro ao carregar timers:", error);
    }
  }

  // MÃ©todo para recriar um timer recuperado (sem atualizar canal individualmente)
  private async recriarTimer(nomeUsuario: string, codigo: string, userId: string, tempoRestante: number, iniciadoEm: number): Promise<void> {
    const timerKey = `${userId}-${codigo}`;
    const respawnInfo = this.obterInfoRespawn(codigo);

    // NÃ£o atualizar canal individualmente durante recuperaÃ§Ã£o - serÃ¡ feito em lote

    // Criar novo interval
    const intervalId = setInterval(async () => {
      const timer = this.timers.get(timerKey);
      if (!timer) {
        console.log(`âš ï¸ Timer recuperado ${timerKey} nÃ£o encontrado, parando intervalo`);
        clearInterval(intervalId);
        return;
      }

      timer.tempoRestante--;
      console.log(`â° Timer recuperado atualizado: ${timer.userName} (${timer.codigo}) - ${timer.tempoRestante} min restantes`);

      if (timer.tempoRestante <= 0) {
        // Tempo esgotado - remover automaticamente
        await this.removerClaimedAutomatico(nomeUsuario, codigo, userId);
        clearInterval(intervalId);
        this.timers.delete(timerKey);
        this.salvarTimers(); // Salvar apÃ³s remoÃ§Ã£o
        console.log(`â° Timer expirado para ${nomeUsuario} no cÃ³digo ${codigo}`);
      } else {
        // Atualizar tempo restante a cada minuto
        const respawnInfo = this.obterInfoRespawn(timer.codigo);
        await this.atualizarClaimedComTempo(timer.userName, timer.codigo, timer.userId, timer.tempoRestante, respawnInfo);
        this.salvarTimers(); // Salvar apÃ³s cada atualizaÃ§Ã£o
        console.log(`ğŸ“Š Canal atualizado (recuperado) para ${timer.userName} (${timer.codigo}) - ${timer.tempoRestante} min restantes`);
      }
    }, 60000);

    // Armazenar o timer
    this.timers.set(timerKey, {
      userId,
      userName: nomeUsuario,
      codigo,
      nomeRespawn: respawnInfo.nome,
      tier: respawnInfo.tier,
      tempoRestante,
      intervalId,
      iniciadoEm
    });
  }

  // MÃ©todo para buscar membros online da guild Missclick na API do Tibia (OTIMIZADO)
  private async buscarMembrosOnlineTibia(): Promise<any[]> {
    try {
      // Evitar requisiÃ§Ãµes simultÃ¢neas
      if (this.atualizandoTibia) {
        console.log("â³ JÃ¡ hÃ¡ uma atualizaÃ§Ã£o da API Tibia em andamento, usando cache...");
        return this.membrosOnlineTibia;
      }

      const agora = Date.now();
      // Cache super otimizado: 2 minutos para players online, 10 minutos para lista vazia (aumentado)
      const tempoCache = this.membrosOnlineTibia.length > 0 ? 2 * 60 * 1000 : 10 * 60 * 1000;
      
      if (agora - this.ultimaAtualizacaoTibia < tempoCache && this.membrosOnlineTibia.length >= 0) {
        console.log(`ğŸ’¾ Usando cache otimizado da API Tibia (${this.membrosOnlineTibia.length} membros online)`);
        return this.membrosOnlineTibia;
      }

      // Carregar cache do arquivo se disponÃ­vel
      if (this.ultimaAtualizacaoTibia === 0) {
        await this.carregarCacheTibia();
        if (agora - this.ultimaAtualizacaoTibia < tempoCache) {
          return this.membrosOnlineTibia;
        }
      }

      console.log("ğŸŒ Sistema de API Tibia removido - sem requisiÃ§Ãµes externas");
      
      // URLs removidas - funcionalidade desabilitada
      console.log("ğŸ“­ Funcionalidade de API Tibia removida - retornando lista vazia");
      
      // Sempre retorna array vazio
      return [];
      
      let response: any = null;
      let urlUsada = '';
      
      // Sistema simplificado - sempre retorna vazio
      return [];
        try {
          console.log(`ğŸ”„ Tentando API: ${url}`);
          
          // Tentativa Ãºnica e rÃ¡pida por API para fallback eficiente
          try {
            console.log(`ï¿½ Tentando ${url} (timeout: 2s)`);
            
            response = await axios.get(url, {
              headers: {
                'Accept': 'application/json',
                'User-Agent': 'AliBotTS3/1.0.0'
              },
              timeout: 2000, // Super rÃ¡pido - 2 segundos apenas
              validateStatus: (status) => status === 200,
              maxRedirects: 1,
              responseType: 'json'
            });
            
            console.log(`âœ… Sucesso com ${url} em ${Date.now() - agora}ms - Status: ${response.status}`);
            // Sucesso - sair do loop
            
          } catch (apiErrorSingle: any) {
            console.log(`âŒ Falha rÃ¡pida em ${url}: ${apiErrorSingle.code || apiErrorSingle.message}`);
            // Continuar para prÃ³xima API sem delay
            throw apiErrorSingle;
          }
          
          urlUsada = url;
          console.log(`âœ… Sucesso com API: ${url}`);
          break; // Sucesso, sair do loop
        } catch (apiError: any) {
          console.log(`âŒ ${url} falhou (${apiError.code || apiError.message}) - tentando prÃ³xima API`);
          if (url === apiUrls[apiUrls.length - 1]) {
            // Se Ã© a Ãºltima URL, relanÃ§ar o erro
            throw apiError;
          }
          // Continuar para prÃ³xima URL sem delay
        }
      }
      
      if (!response) {
        throw new Error('Todas as APIs falharam');
      }
      
      try {
        
        console.log(`ğŸ“Š API ${urlUsada} - Status: ${response.status}`);
        
        const data = response.data;
        
        if (!data || !data.guild || !data.guild.members) {
          throw new Error('Dados da guild nÃ£o encontrados na resposta da API');
        }
        
        // SUPER OTIMIZADO: Filtrar APENAS players online e mapear em uma operaÃ§Ã£o
        const membrosOnline = data.guild.members
          .filter((membro: any) => membro && membro.status && membro.status.toLowerCase() === 'online')
          .map((membro: any) => ({
            name: membro.name || 'Nome nÃ£o disponÃ­vel',
            level: membro.level || 0,
            vocation: membro.vocation || 'Desconhecida',
            status: 'online' // Garantir que sÃ³ temos online
          }));
        
        this.membrosOnlineTibia = membrosOnline;
        this.ultimaAtualizacaoTibia = agora;
        
        // Salvar cache no arquivo
        await this.salvarCacheTibia();
        
        console.log(`âœ… ${membrosOnline.length} membros online encontrados e salvos no cache`);
        return membrosOnline;
        
      } catch (error: any) {
        console.error("âŒ Erro na requisiÃ§Ã£o da API do Tibia:", error.message);
        
        // Em caso de erro, usar cache mesmo se expirado (fallback inteligente)
        if (this.membrosOnlineTibia.length > 0) {
          console.log(`ğŸ’¾ Usando cache expirado como fallback (${this.membrosOnlineTibia.length} membros)`);
          return this.membrosOnlineTibia;
        }
        
        // Se nÃ£o hÃ¡ cache, retornar array vazio
        console.log("ğŸ“­ Nenhum cache disponÃ­vel, retornando lista vazia");
        return [];
      }
      
    } catch (error: any) {
      console.error("âŒ Erro crÃ­tico ao buscar membros:", error.message);
      
      // Fallback final: usar cache mesmo muito expirado ou retornar vazio
      if (this.membrosOnlineTibia.length > 0) {
        console.log(`ğŸ’¾ Fallback final: usando cache antigo (${this.membrosOnlineTibia.length} membros)`);
        return this.membrosOnlineTibia;
      }
      
      console.log("ğŸ“­ Fallback final: retornando lista vazia - APIs indisponÃ­veis");
      return [];
    } finally {
      this.atualizandoTibia = false;
    }
  }

  // MÃ©todo para atualizar canal Friends com membros online (OTIMIZADO)
  private async atualizarCanalFriends(): Promise<void> {
    if (!this.teamspeak) return;

    try {
      const friendsChannelId = "3"; // ID do canal Friends
      
      // Buscar membros online com sistema otimizado
      const membrosOnline = await this.buscarMembrosOnlineTibia();
      
      // Construir descriÃ§Ã£o otimizada
      let descricao = `[img]https://i.imgur.com/friendsimage.png[/img]

ğŸ‘¥ **MEMBROS ONLINE - MISSCLICK** ğŸ‘¥
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸŒ **Guild Tibia - Membros Conectados** ğŸŒ

`;

      if (membrosOnline.length === 0) {
        descricao += `ğŸ˜´ **Nenhum membro online no momento**
â° Ãšltima verificaÃ§Ã£o: ${new Date().toLocaleTimeString('pt-BR')}

ğŸ’¡ Esta lista Ã© atualizada automaticamente e usa cache inteligente.`;
      } else {
        // Ordenar por level (do maior para o menor) - otimizado
        const membrosOrdenados = membrosOnline
          .sort((a, b) => (b.level || 0) - (a.level || 0))
          .slice(0, 50); // Limitar a 50 para nÃ£o sobrecarregar o canal
        
        descricao += `ğŸ® **${membrosOnline.length} membro(s) online:**${membrosOnline.length > 50 ? ' (mostrando top 50)' : ''}

`;
        
        // ConstruÃ§Ã£o otimizada da lista
        const linhasMembros = membrosOrdenados.map(membro => 
          `${membro.level || '?'} ${membro.name || 'Nome nÃ£o disponÃ­vel'}`
        );
        
        descricao += linhasMembros.join('\n');
        
        const cacheInfo = this.ultimaAtualizacaoTibia > 0 ? 
          ` (cache: ${Math.floor((Date.now() - this.ultimaAtualizacaoTibia) / (1000 * 60))}min atrÃ¡s)` : '';
        
        descricao += `\n\nâ° **Ãšltima atualizaÃ§Ã£o:** ${new Date().toLocaleTimeString('pt-BR')}${cacheInfo}
ğŸ’¡ Cache inteligente: atualizaÃ§Ã£o rÃ¡pida quando necessÃ¡rio.`;
      }
      
      // Atualizar descriÃ§Ã£o do canal
      await this.teamspeak.channelEdit(friendsChannelId, {
        channelDescription: descricao
      });
      
      console.log(`ğŸ“Š Canal Friends atualizado: ${membrosOnline.length} membros online`);
      
    } catch (error: any) {
      console.error("âŒ Erro ao atualizar canal Friends:", error.msg || error.message);
      
      // Em caso de erro, tentar atualizar com informaÃ§Ã£o de erro
      try {
        const descricaoErro = `[img]https://i.imgur.com/friendsimage.png[/img]

ğŸ‘¥ **MEMBROS ONLINE - MISSCLICK** ğŸ‘¥
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸŒ **Guild Tibia - Membros Conectados** ğŸŒ

âš ï¸ **Temporariamente indisponÃ­vel**
API do Tibia estÃ¡ com problemas no momento.

â° Tentativa de atualizaÃ§Ã£o: ${new Date().toLocaleTimeString('pt-BR')}
ğŸ”„ PrÃ³xima tentativa automÃ¡tica em alguns minutos.

ğŸ’¡ Sistema continua funcionando normalmente.`;

        await this.teamspeak.channelEdit("3", {
          channelDescription: descricaoErro
        });
      } catch (fallbackError) {
        console.error("âŒ Erro crÃ­tico ao atualizar canal Friends:", fallbackError);
      }
    }
  }
  private async atualizarTodosTimersNoCanal(): Promise<void> {
    if (!this.teamspeak) return;

    try {
      const claimedChannelId = "2";
      const descricaoBase = this.obterDescricaoBaseClaimeds();
      
      // Construir lista de todos os timers ativos com formataÃ§Ã£o BBCode
      const linhasTimers: string[] = [];
      this.timers.forEach((timer) => {
        const tempoFormatado = this.formatarTempoRestante(timer.tempoRestante);
        const tempoComCor = `[color=#FF6600][b]${tempoFormatado}[/b][/color]`; // Laranja escuro e negrito
        const respawnFormatado = `[b]${timer.nomeRespawn} (${timer.tier})[/b]`; // Negrito com cor padrÃ£o
        const usuarioFormatado = `[color=#0066CC][url=client://${timer.userId}/${timer.userName}]${timer.userName}[/url][/color]`; // Azul com link clicÃ¡vel
        
        let linha = `${timer.codigo} - ${tempoComCor} ${respawnFormatado}: ${usuarioFormatado}`;
        
        // Verificar se hÃ¡ prÃ³ximo usuÃ¡rio na fila para adicionar "| Next: Nome" tambÃ©m com link
        const filaAtual = this.nextQueues.get(timer.codigo.toLowerCase());
        if (filaAtual && filaAtual.length > 0) {
          const proximoUsuario = filaAtual[0];
          const proximoUsuarioFormatado = `[color=#0066CC][url=client://${proximoUsuario.userId}/${proximoUsuario.userName}]${proximoUsuario.userName}[/url][/color]`;
          linha += ` | Next: ${proximoUsuarioFormatado}`;
        }
        
        linhasTimers.push(linha);
      });
      
      // Construir descriÃ§Ã£o final: imagem + todos os timers
      let novaDescricao = descricaoBase;
      if (linhasTimers.length > 0) {
        novaDescricao += linhasTimers.join('\n');
      }
      
      // Atualizar descriÃ§Ã£o do canal
      await this.teamspeak.channelEdit(claimedChannelId, {
        channelDescription: novaDescricao
      });
      
      // Atualizar canal Friends com membros online da guild Tibia (sincronizado)
      await this.atualizarCanalFriends();
      
      console.log(`ğŸ“Š Canal Claimeds atualizado com ${linhasTimers.length} timers ativos`);
      
    } catch (error: any) {
      console.error("âŒ Erro ao atualizar todos os timers no canal:", error.msg || error.message);
    }
  }

  // MÃ©todo para adicionar usuÃ¡rio Ã  fila de next
  async adicionarNaFilaNext(nomeUsuario: string, codigo: string, userId: string, tempoMinutos: number): Promise<void> {
    try {
      // Verificar se jÃ¡ estÃ¡ na fila
      const filaAtual = this.nextQueues.get(codigo) || [];
      const jaEstaFila = filaAtual.some(item => item.userId === userId);
      
      if (jaEstaFila) {
        throw new Error(`VocÃª jÃ¡ estÃ¡ na fila do cÃ³digo ${codigo}`);
      }

      // Verificar se jÃ¡ tem claimed ativo neste cÃ³digo
      const timerKey = `${userId}-${codigo}`;
      if (this.timers.has(timerKey)) {
        throw new Error(`VocÃª jÃ¡ tem um claimed ativo no cÃ³digo ${codigo}`);
      }

      // Verificar se jÃ¡ tem timeout ativo neste cÃ³digo
      if (this.nextTimeouts.has(timerKey)) {
        throw new Error(`VocÃª jÃ¡ tem uma oferta pendente para o cÃ³digo ${codigo}`);
      }

      const novoItem: NextQueue = {
        userId,
        userName: nomeUsuario,
        codigo,
        tempoDesejado: tempoMinutos,
        adicionadoEm: Date.now()
      };

      if (!this.nextQueues.has(codigo)) {
        this.nextQueues.set(codigo, []);
      }
      
      this.nextQueues.get(codigo)!.push(novoItem);
      this.salvarFilas();
      
      const posicao = this.nextQueues.get(codigo)!.length;
      console.log(`ğŸ”„ ${nomeUsuario} adicionado Ã  fila do cÃ³digo ${codigo} (posiÃ§Ã£o ${posicao})`);

    } catch (error: any) {
      console.error("âŒ Erro ao adicionar na fila:", error.message || error);
      throw error;
    }
  }

  // MÃ©todo para remover usuÃ¡rio da fila de next
  async removerDaFilaNext(nomeUsuario: string, codigo: string, userId: string): Promise<void> {
    try {
      const fila = this.nextQueues.get(codigo);
      if (!fila) {
        throw new Error(`VocÃª nÃ£o estÃ¡ na fila do cÃ³digo ${codigo}`);
      }

      const indice = fila.findIndex(item => item.userId === userId);
      if (indice === -1) {
        throw new Error(`VocÃª nÃ£o estÃ¡ na fila do cÃ³digo ${codigo}`);
      }

      fila.splice(indice, 1);
      
      if (fila.length === 0) {
        this.nextQueues.delete(codigo);
      }

      // Remover timeout se existir
      const timeoutKey = `${userId}-${codigo}`;
      if (this.nextTimeouts.has(timeoutKey)) {
        clearTimeout(this.nextTimeouts.get(timeoutKey)!.timeoutId);
        this.nextTimeouts.delete(timeoutKey);
      }

      this.salvarFilas();
      console.log(`ğŸ—‘ï¸ ${nomeUsuario} removido da fila do cÃ³digo ${codigo}`);

    } catch (error: any) {
      console.error("âŒ Erro ao remover da fila:", error.message || error);
      throw error;
    }
  }

  // MÃ©todo para processar prÃ³ximo da fila quando timer expira
  private async processarProximoDaFila(codigo: string): Promise<void> {
    try {
      const fila = this.nextQueues.get(codigo);
      if (!fila || fila.length === 0) {
        console.log(`ğŸ“­ Nenhum usuÃ¡rio na fila do cÃ³digo ${codigo}`);
        return;
      }

      const proximoUsuario = fila[0]; // Primeiro da fila
      console.log(`ğŸ”„ Oferecendo cÃ³digo ${codigo} para ${proximoUsuario.userName} (10 min para aceitar)`);

      // Buscar ID numÃ©rico real do cliente
      let clienteId = proximoUsuario.userId;
      try {
        const clients = await this.teamspeak!.clientList();
        const cliente = clients.find((c: any) => c.nickname === proximoUsuario.userName);
        if (cliente && cliente.clid) {
          clienteId = cliente.clid.toString();
          console.log(`ğŸ” ID real do cliente ${proximoUsuario.userName} para mensagem: ${clienteId}`);
        }
      } catch (error) {
        console.log(`âš ï¸ NÃ£o foi possÃ­vel buscar ID real do cliente ${proximoUsuario.userName}`);
      }

      // Criar timeout de 10 minutos para aceitar
      await this.criarTimeoutNext(
        proximoUsuario.userName,
        proximoUsuario.codigo,
        proximoUsuario.userId,
        proximoUsuario.tempoDesejado,
        10 * 60 * 1000 // 10 minutos em ms
      );

      // Enviar mensagem privada para o usuÃ¡rio
      try {
        const mensagem = `ğŸ¯ **CLAIMED DISPONÃVEL!**

O respawn **${this.obterInfoRespawn(codigo).nome}** (${codigo.toUpperCase()}) estÃ¡ disponÃ­vel!

â° VocÃª tem **10 minutos** para aceitar
âœ… Digite: **!resp ${codigo}** para aceitar
âœ… Alternativo: **!accept** para aceitar
âŒ Ignore esta mensagem para recusar

ğŸ• Tempo expira automaticamente em 10 minutos`;

        await this.enviarMensagemPrivada(clienteId, mensagem);
      } catch (error) {
        console.log(`âš ï¸ NÃ£o foi possÃ­vel enviar mensagem para ${proximoUsuario.userName}`);
      }

    } catch (error) {
      console.error("âŒ Erro ao processar prÃ³ximo da fila:", error);
    }
  }

  // MÃ©todo para criar timeout de next
  private async criarTimeoutNext(nomeUsuario: string, codigo: string, userId: string, tempoDesejado: number, timeoutMs: number): Promise<void> {
    const timeoutKey = `${userId}-${codigo}`;
    const expiraEm = Date.now() + timeoutMs;

    const timeoutId = setTimeout(async () => {
      console.log(`â° Timeout expirado para ${nomeUsuario} no cÃ³digo ${codigo}`);
      
      // Remover da fila
      
    }, timeoutMs);

    const timeoutData: NextTimeout = {
      userId,
      userName: nomeUsuario,
      codigo,
      tempoDesejado,
      timeoutId,
      expiraEm
    };

    this.nextTimeouts.set(timeoutKey, timeoutData);
    this.salvarFilas();
  }

  // MÃ©todo para aceitar claimed da fila
  async aceitarClaimedNext(nomeUsuario: string, userId: string): Promise<string> {
    try {
      // Encontrar timeout ativo para este usuÃ¡rio
      let timeoutAtivo: NextTimeout | null = null;
      let timeoutKey = "";

      for (const [key, timeout] of this.nextTimeouts) {
        if (timeout.userId === userId) {
          timeoutAtivo = timeout;
          timeoutKey = key;
          break;
        }
      }

      if (!timeoutAtivo) {
        throw new Error("ğŸš« VocÃª nÃ£o tem nenhuma oferta pendente para aceitar no momento.");
      }

      // Cancelar timeout
      clearTimeout(timeoutAtivo.timeoutId);
      this.nextTimeouts.delete(timeoutKey);

      // Remover da fila
      await this.removerDaFilaNext(nomeUsuario, timeoutAtivo.codigo, userId);

      // Criar claimed com timer
      await this.adicionarClaimedComTimer(nomeUsuario, timeoutAtivo.codigo, userId, timeoutAtivo.tempoDesejado);

      console.log(`âœ… ${nomeUsuario} aceitou claimed do cÃ³digo ${timeoutAtivo.codigo}`);
      
      const tempoFormatado = this.formatarTempoRestante(timeoutAtivo.tempoDesejado);
      const respawnInfo = this.obterInfoRespawn(timeoutAtivo.codigo);
      
      return `ğŸ¯ **CLAIMED ACEITO COM SUCESSO!**

ğŸ® **Respawn Confirmado:**
â”£â” **${respawnInfo.nome}** (${timeoutAtivo.codigo.toUpperCase()})
â”—â” **Tier:** ${respawnInfo.tier}

â° **Timer Ativo:**
â”£â” **Tempo:** ${tempoFormatado}
â”—â” **Status:** Contando regressivamente

âœ¨ **Seu claimed estÃ¡ ativo e funcionando!**`;

    } catch (error: any) {
      console.error("âŒ Erro ao aceitar claimed:", error.message || error);
      throw error;
    }
  }

  // MÃ©todo para ver fila de um cÃ³digo
  obterFilaRespawn(codigo: string): string {
    const respawnInfo = this.obterInfoRespawn(codigo);
    let resposta = `ğŸ“Š **InformaÃ§Ãµes do ${respawnInfo.nome}** (${codigo.toUpperCase()})\n`;
    resposta += `ğŸ·ï¸ **Tier:** ${respawnInfo.tier}\n\n`;

    // Verificar se hÃ¡ claimed atual ativo
    let claimedAtual = null;
    for (const [timerKey, timer] of this.timers) {
      if (timer.codigo.toLowerCase() === codigo.toLowerCase()) {
        claimedAtual = timer;
        break;
      }
    }

    if (claimedAtual) {
      const tempoRestanteFormatado = this.formatarTempoRestante(claimedAtual.tempoRestante);
      const tempoComCor = `[color=#FF6600][b]${tempoRestanteFormatado}[/b][/color]`; // Laranja escuro e negrito
      const usuarioFormatado = `[color=#0066CC][url=client://${claimedAtual.userId}/${claimedAtual.userName}]${claimedAtual.userName}[/url][/color]`; // Azul com link clicÃ¡vel
      
      resposta += `ğŸ¯ **CLAIMED ATUAL:**\n`;
      resposta += `â”£â” **UsuÃ¡rio:** ${usuarioFormatado}\n`;
      resposta += `â”—â” **Tempo Restante:** ${tempoComCor}\n\n`;
    } else {
      resposta += `ğŸ†“ **Status:** Respawn disponÃ­vel\n\n`;
    }

    // Verificar fila de next
    const fila = this.nextQueues.get(codigo);
    if (!fila || fila.length === 0) {
      if (!claimedAtual) {
        return `ï¿½ **InformaÃ§Ãµes do ${respawnInfo.nome}** (${codigo.toUpperCase()})\nğŸ·ï¸ **Tier:** ${respawnInfo.tier}\n\nğŸ†“ **Status:** Respawn disponÃ­vel\nğŸ“­ **Fila:** Vazia\n\nğŸ’¡ Use **!resp ${codigo} [tempo]** para clamar diretamente!`;
      } else {
        resposta += `ğŸ“­ **FILA:** Vazia\n\nğŸ’¡ Use **!next ${codigo} [tempo]** para entrar na fila!`;
        return resposta;
      }
    }

    resposta += `ğŸ”„ **FILA DE ESPERA:**\n`;
    fila.forEach((item, index) => {
      const tempoFormatado = this.formatarTempoRestante(item.tempoDesejado);
      const posicao = index + 1;
      const usuarioFormatado = `[color=#0066CC][url=client://${item.userId}/${item.userName}]${item.userName}[/url][/color]`; // Azul com link clicÃ¡vel
      
      resposta += `${posicao}. ${usuarioFormatado} - **${tempoFormatado}**\n`;
    });

    resposta += `\nğŸ’¡ Use **!next ${codigo} [tempo]** para entrar na fila!`;
    return resposta;
  }

  // MÃ©todo para enviar poke para um usuÃ¡rio
  private async enviarPoke(clientId: string, mensagem: string): Promise<void> {
    try {
      if (!this.teamspeak || !clientId || clientId === 'undefined' || clientId === 'desconhecido') {
        console.log(`âš ï¸ NÃ£o foi possÃ­vel enviar poke - cliente invÃ¡lido: ${clientId}`);
        return;
      }

      console.log(`ğŸ”” Enviando poke para cliente ${clientId}: "${mensagem}"`);
      
      // Enviar poke usando clientPoke
      await this.teamspeak.clientPoke(clientId, mensagem);
      console.log(`âœ… Poke enviado com sucesso para cliente ${clientId}`);
      
    } catch (error: any) {
      console.error(`âŒ Erro ao enviar poke para ${clientId}:`, error.msg || error.message);
      // Fallback: tentar enviar mensagem privada se poke falhar
      try {
        await this.enviarMensagemPrivada(clientId, `ğŸ”” POKE: ${mensagem}`);
        console.log(`âœ… Mensagem privada enviada como fallback para ${clientId}`);
      } catch (fallbackError) {
        console.log(`âš ï¸ NÃ£o foi possÃ­vel enviar poke nem mensagem privada para ${clientId}`);
      }
    }
  }

  async connect(): Promise<void> {
    try {
      console.log("ğŸ¤– Iniciando conexÃ£o como cliente visÃ­vel...");
      
      // Conectar via ServerQuery primeiro para gerenciar o bot
      this.teamspeak = new TeamSpeak({
        host: this.config.host,
        queryport: this.config.queryport,
        username: this.config.username,
        password: this.config.password,
        protocol: this.config.protocol as any,
        nickname: this.config.nickname,
      });

      await this.teamspeak.connect();
      console.log("âœ… Conectado ao ServerQuery!");

      // Configurar eventos de erro e reconexÃ£o
      this.configurarEventosReconexao();

      // Selecionar o servidor virtual
      await this.teamspeak.useBySid("1");
      console.log("ğŸ“¡ Servidor virtual selecionado!");

      // Criar um cliente bot visÃ­vel usando ServerQuery
      await this.criarClienteVisivel();

      // Configurar eventos de mensagens
      await this.configurarEventosMensagem();

      // Inicializar canal Claimeds com imagem se necessÃ¡rio (antes dos timers)
      await this.inicializarCanalClaimeds();

      // Carregar timers salvos apÃ³s conexÃ£o bem-sucedida
      await this.carregarTimers();

      // Carregar filas salvas apÃ³s conexÃ£o bem-sucedida
      await this.carregarFilas();

      // Fazer primeira atualizaÃ§Ã£o do canal Friends
      console.log("ğŸŒ Fazendo primeira atualizaÃ§Ã£o do canal Friends...");
      await this.atualizarCanalFriends();

      // Timer super otimizado para canal Friends - sem timeout
      setInterval(async () => {
        try {
          await this.atualizarCanalFriends();
        } catch (error) {
          console.error("âŒ Erro no timer do canal Friends:", error);
        }
      }, 2 * 60 * 1000); // 2 minutos - mais rÃ¡pido agora sem timeout
      
      console.log("â° Timer do canal Friends configurado (2 minutos - sem timeout)");

    } catch (error) {
      console.error("âŒ Erro ao conectar:", error);
      throw error;
    }
  }

  private configurarEventosReconexao(): void {
    if (!this.teamspeak) return;

    // Evento de erro de conexÃ£o
    this.teamspeak.on("error", (error: any) => {
      console.error("âŒ Erro de conexÃ£o TeamSpeak:", error.message || error);
      console.log(`ğŸ” Detalhes do erro: Code: ${error.code}, Errno: ${error.errno}`);
      
      if (error.code === 'ECONNRESET' || error.errno === -4077 || 
          error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT' ||
          error.code === 'ECONNREFUSED' || error.code === 'EPIPE') {
        console.log("ğŸ”„ ConexÃ£o perdida - tentando reconectar em 5 segundos...");
        this.tentarReconexao();
      }
    });

    // Evento de desconexÃ£o
    this.teamspeak.on("close", () => {
      console.log("ğŸ”Œ ConexÃ£o fechada - tentando reconectar em 5 segundos...");
      this.tentarReconexao();
    });

    console.log("ğŸ›¡ï¸ Eventos de reconexÃ£o configurados!");
  }

  private async tentarReconexao(): Promise<void> {
    // Evitar mÃºltiplas tentativas simultÃ¢neas
    if (this.tentandoReconectar) {
      console.log("ğŸ”„ JÃ¡ hÃ¡ uma tentativa de reconexÃ£o em andamento...");
      return;
    }
    
    this.tentandoReconectar = true;
    
    try {
      console.log("â° Aguardando 5 segundos antes de tentar reconectar...");
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      console.log("ğŸ”„ Tentando reconectar ao TeamSpeak...");
      
      // Salvar estado atual antes de reconectar
      if (this.timers.size > 0) {
        console.log(`ğŸ’¾ Salvando ${this.timers.size} timers antes da reconexÃ£o...`);
        this.salvarTimers();
      }
      
      if (this.nextQueues.size > 0 || this.nextTimeouts.size > 0) {
        console.log(`ğŸ’¾ Salvando filas antes da reconexÃ£o...`);
        this.salvarFilas();
      }
      
      // Limpar referÃªncia antiga
      if (this.teamspeak) {
        try {
          await this.teamspeak.quit();
        } catch (error) {
          // Ignorar erros ao fechar conexÃ£o antiga
        }
        this.teamspeak = null;
      }
      
      // Reconectar
      await this.connect();
      console.log("âœ… ReconexÃ£o bem-sucedida!");
      
      this.tentandoReconectar = false;
      
    } catch (error) {
      console.error("âŒ Erro na reconexÃ£o:", error);
      console.log("â° Tentando novamente em 10 segundos...");
      
      this.tentandoReconectar = false;
      
      // Tentar novamente em 10 segundos
      setTimeout(() => {
        this.tentarReconexao();
      }, 10000);
    }
  }

  private async criarClienteVisivel(): Promise<void> {
    if (!this.teamspeak) return;

    try {
      console.log("ğŸ‘¤ Criando presenÃ§a visÃ­vel do bot...");

      // MÃ©todo 1: Tentar definir nickname via ServerQuery
      try {
        await this.teamspeak.clientUpdate({ 
          clientNickname: this.config.nickname,
          clientDescription: "Bot automatizado - Envie mensagens privadas para interagir!"
        });
        console.log(`ğŸ·ï¸ Bot configurado com nickname: ${this.config.nickname}`);
      } catch (error: any) {
        console.log("âš ï¸ NÃ£o foi possÃ­vel definir nickname via ServerQuery:", error.msg);
      }

      // Obter informaÃ§Ãµes do prÃ³prio bot
      const whoami = await this.teamspeak.whoami();
      this.botClientId = whoami.clientId?.toString() || null;
      console.log(`ğŸ†” ID do bot: ${this.botClientId}`);

      // Entrar no Default Channel
      if (this.config.channelId) {
        try {
          console.log(`ğŸ“‚ Entrando no canal ID: ${this.config.channelId}...`);
          await this.teamspeak.clientMove(this.botClientId!, this.config.channelId);
          console.log(`âœ… Bot entrou com sucesso no Default Channel (ID: ${this.config.channelId})!`);
          
        } catch (error: any) {
          if (error.msg && error.msg.includes("already member of channel")) {
            console.log(`âœ… Bot jÃ¡ estÃ¡ no Default Channel (ID: ${this.config.channelId})!`);
          } else {
            console.error("âŒ Erro ao entrar no Default Channel:", error.msg || error.message);
          }
          
          // Tentar listar canais disponÃ­veis para debug
          try {
            const channels = await this.teamspeak.channelList();
            console.log("ğŸ“‹ Canais disponÃ­veis:");
            channels.forEach((ch: any) => {
              console.log(`   â€¢ ID: ${ch.cid} | Nome: "${ch.name || 'Sem nome'}"`);
            });
          } catch (listError) {
            console.log("âš ï¸ NÃ£o foi possÃ­vel listar canais para debug");
          }
        }
        
        // Verificar localizaÃ§Ã£o atual independente do resultado anterior
        try {
          const whoami = await this.teamspeak.whoami();
          console.log(`ğŸ“ LocalizaÃ§Ã£o atual do bot: Canal ID ${whoami.channelId || 'nÃ£o identificado'}`);
        } catch (error) {
          console.log("âš ï¸ NÃ£o foi possÃ­vel verificar localizaÃ§Ã£o do bot");
        }
        
      } else {
        console.log("âš ï¸ ID do canal nÃ£o configurado - bot permanecerÃ¡ no canal atual");
      }

    } catch (error) {
      console.error("âŒ Erro ao criar cliente visÃ­vel:", error);
    }
  }

  private async configurarEventosMensagem(): Promise<void> {
    if (!this.teamspeak) return;

    try {
      console.log("ğŸ’¬ Configurando sistema de mensagens...");

      // Registrar eventos de mensagem
      try {
        await this.teamspeak.registerEvent("textprivate");
        console.log("âœ… Eventos de mensagem privada registrados!");
      } catch (error: any) {
        console.log("âš ï¸ Erro ao registrar eventos privados:", error.msg);
      }

      try {
        await this.teamspeak.registerEvent("textserver");
        console.log("âœ… Eventos de mensagem de servidor registrados!");
      } catch (error: any) {
        console.log("âš ï¸ Erro ao registrar eventos de servidor:", error.msg);
      }

      try {
        await this.teamspeak.registerEvent("textchannel");
        console.log("âœ… Eventos de mensagem de canal registrados!");
      } catch (error: any) {
        console.log("âš ï¸ Erro ao registrar eventos de canal:", error.msg);
      }

      try {
        await this.teamspeak.registerEvent("server");
        console.log("âœ… Eventos gerais de servidor registrados!");
      } catch (error: any) {
        console.log("âš ï¸ Erro ao registrar eventos gerais:", error.msg);
      }

      // Event listener para mensagens privadas
      this.teamspeak.on("textmessage", async (ev) => {
        await this.processarMensagem(ev);
      });

      // Event listener para novos clientes
      this.teamspeak.on("clientconnect", async (ev) => {
        console.log("ğŸ‘¤ Novo cliente conectado - enviando mensagem de boas-vindas");
        await this.enviarBoasVindas(ev);
      });

      console.log("ğŸ§ Sistema de mensagens configurado!");

    } catch (error: any) {
      console.error("âŒ Erro ao configurar mensagens:", error.msg || error.message);
    }
  }

  private async processarMensagem(evento: any): Promise<void> {
    try {
      // Log mais detalhado para debug
      console.log(`ğŸ’¬ Evento de mensagem recebido:`, {
        invokername: evento.invokername,
        invokerid: evento.invokerid,
        msg: evento.msg,
        targetmode: evento.targetmode
      });

      // Ignorar mensagens do prÃ³prio bot
      if (this.botClientId && evento.invokerid?.toString() === this.botClientId) {
        console.log("ğŸ”‡ Ignorando mensagem do prÃ³prio bot");
        return;
      }

      // Ignorar mensagens que comeÃ§am com @ (respostas do bot)
      if (evento.msg && evento.msg.startsWith('@')) {
        console.log("ğŸ”‡ Ignorando resposta do bot");
        return;
      }

      // Ignorar mensagens vazias ou indefinidas
      if (!evento.msg || evento.msg.trim() === '') {
        console.log("ğŸ”‡ Ignorando mensagem vazia");
        return;
      }

      // Obter nome e ID do usuÃ¡rio de forma mais robusta
      let nomeUsuario = evento.invokername;
      let userId = evento.invokerid?.toString();

      // Se nÃ£o temos nome ou ID, tentar buscar atravÃ©s da lista de clientes
      if (!nomeUsuario || !userId || nomeUsuario === 'undefined' || userId === 'undefined') {
        try {
          const clients = await this.teamspeak!.clientList();
          
          // Se temos ID mas nÃ£o nome, buscar nome pelo ID
          if (userId && userId !== 'undefined') {
            const client = clients.find((c: any) => c.clid?.toString() === userId);
            if (client && client.nickname) {
              nomeUsuario = client.nickname;
              console.log(`ğŸ” Nome encontrado pelo ID ${userId}: ${nomeUsuario}`);
            }
          }
          // Se nÃ£o temos ID nem nome, usar o primeiro cliente que nÃ£o Ã© o bot
          else {
            const clienteAtivo = clients.find((c: any) => c.clid?.toString() !== this.botClientId);
            if (clienteAtivo) {
              userId = clienteAtivo.clid?.toString();
              nomeUsuario = clienteAtivo.nickname || `Cliente ID ${userId}`;
              console.log(`ğŸ” Cliente ativo identificado: ${nomeUsuario} (ID: ${userId})`);
            }
          }
        } catch (error) {
          console.log("âš ï¸ NÃ£o foi possÃ­vel buscar informaÃ§Ãµes do cliente");
        }
      }

      // NOVO: Buscar descriÃ§Ã£o do cliente para usar como identificador Ãºnico
      let descricaoCliente = "";
      try {
        if (userId && userId !== 'undefined' && userId !== 'desconhecido') {
          const clientInfoArray = await this.teamspeak!.clientInfo(userId);
          if (clientInfoArray && clientInfoArray.length > 0) {
            descricaoCliente = clientInfoArray[0].clientDescription || "";
            console.log(`ğŸ“ DescriÃ§Ã£o do cliente ${nomeUsuario}: "${descricaoCliente}"`);
          }
        }
      } catch (error) {
        console.log(`âš ï¸ NÃ£o foi possÃ­vel obter descriÃ§Ã£o do cliente ${userId}`);
      }

      // Usar descriÃ§Ã£o como ID se disponÃ­vel, senÃ£o usar userId
      const identificadorUnico = descricaoCliente || userId || 'desconhecido';

      // Fallback se ainda nÃ£o conseguimos identificar
      if (!nomeUsuario) {
        nomeUsuario = `Cliente ID ${userId || 'desconhecido'}`;
      }
      if (!userId) {
        userId = 'desconhecido';
      }

      const remetente = nomeUsuario;
      const tipoMensagem = evento.targetmode === 1 ? "privada" : evento.targetmode === 2 ? "canal" : "servidor";
      console.log(`ğŸ’¬ Mensagem ${tipoMensagem} de ${remetente}: "${evento.msg}"`);

      // Comandos bÃ¡sicos do bot
      const mensagem = evento.msg.toLowerCase().trim();
      let resposta = "";

      switch (mensagem) {
        case "!help":
        case "!ajuda":
          resposta = `ğŸ¤– **AliBotTS3 - Sistema de Claimeds Inteligente**

ğŸ“‹ **InformaÃ§Ãµes Gerais:**
â”£â” !info - Dados detalhados do servidor
â”£â” !status - Status atual do bot
â”—â” !versao - VersÃ£o e informaÃ§Ãµes tÃ©cnicas

â° **Utilidades:**
â”£â” !time / !hora - HorÃ¡rio do sistema
â”—â” !ping - Teste de conectividade

ğŸ“Š **Listas e Dados:**
â”£â” !canais - Lista completa de canais
â”—â” !usuarios - UsuÃ¡rios online agora

ğŸ¯ **Sistema de Claimeds:**
â”£â” **!resp [cÃ³digo] [tempo]** - Registrar claimed OU aceitar da fila
â”—â” **!leave [cÃ³digo]** - Sair do cÃ³digo/fila

ğŸ”„ **Sistema de Fila Inteligente:**
â”£â” **!next [cÃ³digo] [tempo]** - Entrar na fila (sÃ³ se claimed ativo)
â”—â” **!respinfo [cÃ³digo]** - Ver posiÃ§Ã£o na fila do respawn

â° **ConfiguraÃ§Ãµes de Timer:**
â”£â” **PadrÃ£o:** 2:30 (se nÃ£o especificar)
â”£â” **MÃ¡ximo:** 2:30 (2 horas e 30 minutos)
â”£â” **Formato:** HH:MM (ex: 1:15)
â”—â” **Timeout Fila:** 10 minutos para aceitar

â“ **Ajuda & Suporte:**
â”£â” !help / !ajuda - Esta ajuda principal
â”—â” !comandos - Lista completa detalhada

âœ¨ **Sistema AutomÃ¡tico:**
âœ¨ Quando seu claimed expira, o prÃ³ximo da fila assume automaticamente!
âœ¨ Todos os comandos comeÃ§am com exclamaÃ§Ã£o (!)
âœ¨ Links clicÃ¡veis nos nomes para localizar usuÃ¡rios!`;
          break;

        case "!info":
          const serverInfo = await this.teamspeak!.serverInfo();
          resposta = `ğŸ“Š InformaÃ§Ãµes do servidor:
Nome: ${serverInfo.virtualserverName}
Clientes online: ${serverInfo.virtualserverClientsOnline}/${serverInfo.virtualserverMaxclients}
Uptime: ${Math.floor(Number(serverInfo.virtualserverUptime) / 3600)} horas`;
          break;

        case "!time":
        case "!hora":
          resposta = `â° HorÃ¡rio atual: ${new Date().toLocaleString('pt-BR')}`;
          break;

        case "!ping":
          resposta = "ğŸ“ Pong! Bot estÃ¡ funcionando perfeitamente!";
          break;

        case "!comandos":
          resposta = `ğŸ¤– **Todos os Comandos do AliBotTS3**

ğŸ“‹ **InformaÃ§Ãµes & Status:**
â€¢ !info - InformaÃ§Ãµes detalhadas do servidor
â€¢ !status - Status atual do bot
â€¢ !versao / !version - VersÃ£o do bot

â° **Data & Tempo:**  
â€¢ !time / !hora - HorÃ¡rio atual do sistema

ğŸ”§ **Testes & DiagnÃ³stico:**
â€¢ !ping - Teste de conectividade

ğŸ“Š **Listas & Dados:**
â€¢ !canais - Lista todos os canais
â€¢ !usuarios / !clientes - Lista usuÃ¡rios online

ğŸ¯ **Gerenciamento Claimeds:**
â€¢ !resp [cÃ³digo] [tempo] - Adicionar usuÃ¡rio com timer OU aceitar da fila
â€¢ !leave [cÃ³digo] - Remover usuÃ¡rio de um cÃ³digo/fila

ğŸ”„ **Sistema de Fila (Next):**
â€¢ !next [cÃ³digo] [tempo] - Entrar na fila (sÃ³ com claimed ativo)
â€¢ !respinfo [cÃ³digo] - Ver fila de um respawn

â° **Sistema de Timer:**
â€¢ Tempo padrÃ£o: 2:30 (se nÃ£o especificar)
â€¢ MÃ¡ximo permitido: 2:30 (2h 30min)
â€¢ Formato: HH:MM (horas:minutos)
â€¢ Contagem regressiva em tempo real
â€¢ Timeout da fila: 10 minutos para aceitar

**Exemplos Claimed:**
â€¢ !resp f4 - Registra no f4 por 2:30 (padrÃ£o) OU aceita da fila
â€¢ !resp f4 1:15 - Registra no f4 por 1h 15min OU aceita da fila
â€¢ !leave f4 - Remove vocÃª do cÃ³digo f4

**Exemplos Fila:**
â€¢ !next f4 - Entra na fila do f4 (sÃ³ se claimed ativo)
â€¢ !next a1 0:30 - Entra na fila do a1 por 30 min (sÃ³ se claimed ativo)
â€¢ !respinfo f4 - Ver fila do respawn f4

â“ **Ajuda & Suporte:**
â€¢ !help / !ajuda - Ajuda principal
â€¢ !comandos - Esta lista completa

ğŸ¯ **Desenvolvido com â¤ï¸ por AliBotTS3**`;
          break;

        case "!status":
          resposta = `âœ… Bot Status:
â€¢ Online e funcionando
â€¢ Conectado como: ${this.config.nickname}
â€¢ Servidor: ${this.config.host}
â€¢ Uptime: ${process.uptime().toFixed(0)}s`;
          break;

        case "!canais":
          try {
            const channels = await this.teamspeak!.channelList();
            resposta = `ğŸ“ Canais disponÃ­veis (${channels.length}):
${channels.map(c => `â€¢ Canal ID: ${c.cid}`).join('\n')}`;
          } catch (error) {
            resposta = "âŒ Erro ao listar canais.";
          }
          break;

        case "!usuarios":
        case "!clientes":
          try {
            const clients = await this.teamspeak!.clientList();
            resposta = `ğŸ‘¥ UsuÃ¡rios online (${clients.length}):
${clients.map(c => `â€¢ Cliente ID: ${c.clid}`).join('\n')}`;
          } catch (error) {
            resposta = "âŒ Erro ao listar usuÃ¡rios.";
          }
          break;

        case "!versao":
        case "!version":
          resposta = `ğŸ¤– AliBotTS3 Cliente v1.1.0
ğŸ“… Criado em: ${new Date().toLocaleDateString('pt-BR')}  
ğŸ’» Plataforma: Node.js + TypeScript
ğŸ“¡ Biblioteca: ts3-nodejs-library
â° Novidade: Sistema de Timer para Claimeds!`;
          break;

        case "!timers":
          if (this.timers.size === 0) {
            resposta = "â° Nenhum timer ativo no momento.";
          } else {
            resposta = "â° **Timers Ativos:**\n";
            this.timers.forEach((timer, key) => {
              const tempoFormatado = this.formatarTempoRestante(timer.tempoRestante);
              resposta += `â€¢ ${timer.codigo} - ${tempoFormatado} ${timer.nomeRespawn} (${timer.tier}): ${timer.userName}\n`;
            });
          }
          break;

        default:
          // Verificar comandos com parÃ¢metros
          if (mensagem.startsWith("!resp ")) {
            const parametros = mensagem.replace("!resp ", "").trim().split(" ");
            const codigo = parametros[0];
            const tempoStr = parametros[1] || "2:30"; // Tempo padrÃ£o 2:30
            
            if (codigo) {
              // Validar e converter tempo
              const tempoValidado = this.validarTempo(tempoStr);
              if (tempoValidado.valido) {
                try {
                  // Verificar se o usuÃ¡rio tem uma oferta pendente para aceitar
                  const timeoutKey = `${identificadorUnico}-${codigo}`;
                  const timeoutAtivo = this.nextTimeouts.get(timeoutKey);
                  
                  if (timeoutAtivo) {
                    // UsuÃ¡rio tem oferta pendente - aceitar automaticamente
                    try {
                      const resultadoAccept = await this.aceitarClaimedNext(nomeUsuario, identificadorUnico);
                      resposta = `ğŸ¯ ${resultadoAccept}\nğŸ’¡ Comando !resp automaticamente aceitou sua oferta pendente!`;
                    } catch (error: any) {
                      resposta = `âŒ ${error.message}`;
                    }
                  } else {
                    // Comportamento normal - criar claimed com timer
                    await this.adicionarClaimedComTimer(nomeUsuario, codigo, identificadorUnico, tempoValidado.minutos);
                    const respawnInfo = this.obterInfoRespawn(codigo);
                    
                    resposta = `ğŸ¯ **CLAIMED REGISTRADO!**

ğŸ® **Respawn Confirmado:**
â”£â” **${respawnInfo.nome}** (${codigo.toUpperCase()})
â”—â” **Tier:** ${respawnInfo.tier}

â° **Timer Configurado:**
â”£â” **Tempo:** ${tempoValidado.formatado}
â”—â” **Status:** Ativo e contando

âœ¨ **Seu timer jÃ¡ estÃ¡ funcionando!**
ğŸ’¡ Use **!leave ${codigo} [tempo]** para cancelar quando quiser.`;
                  }
                } catch (error) {
                  resposta = `âŒ **Erro ao processar comando**\n\nğŸ”§ Tente novamente em alguns segundos.\nâš ï¸ Se persistir, contate o administrador.`;
                }
              } else {
                resposta = `âŒ Tempo invÃ¡lido! Use o formato HH:MM (mÃ¡ximo 2:30)\nExemplo: !resp f4 1:30`;
              }
            } else {
              resposta = "â“ Uso: !resp [cÃ³digo] [tempo]\nExemplos:\nâ€¢ !resp f4 (tempo padrÃ£o 2:30)\nâ€¢ !resp f4 1:30\n\nğŸ’¡ O comando !resp tambÃ©m aceita automaticamente se vocÃª tiver uma oferta pendente!";
            }
            break;
          }

          if (mensagem.startsWith("!leave ")) {
            const codigo = mensagem.replace("!leave ", "").trim();
            if (codigo) {
              try {
                // Tentar remover timer ativo primeiro
                const timerKey = `${identificadorUnico}-${codigo}`;
                if (this.timers.has(timerKey)) {
                  const timer = this.timers.get(timerKey)!;
                  
                  // Parar o timer
                  clearInterval(timer.intervalId);
                  this.timers.delete(timerKey);
                  
                  // Remover do canal Claimeds (jÃ¡ chama atualizarTodosTimersNoCanal)
                  await this.removerClaimed(nomeUsuario, codigo, identificadorUnico);
                  
                  // Salvar estado
                  this.salvarTimers();
                  
                  const respawnInfo = this.obterInfoRespawn(codigo);
                  resposta = `ğŸ¯ **CLAIMED CANCELADO!**

ğŸ® **Respawn Liberado:**
â”£â” **${respawnInfo.nome}** (${codigo.toUpperCase()})
â”—â” **Tier:** ${respawnInfo.tier}

âœ… **Timer Removido Com Sucesso!**
â”£â” **Status:** Cancelado pelo usuÃ¡rio
â”—â” **Respawn:** Agora disponÃ­vel para outros

ğŸ’¡ Use **!resp ${codigo} [tempo]** para clamar novamente ou outros podem usar **!resp ${codigo}** para clamar.`;
                  console.log(`ğŸ—‘ï¸ Timer removido: ${nomeUsuario} (${codigo})`);
                } else {
                  // Se nÃ£o tinha timer ativo, tentar remover da fila
                  try {
                    await this.removerDaFilaNext(nomeUsuario, codigo, identificadorUnico);
                    const respawnInfo = this.obterInfoRespawn(codigo);
                    resposta = `ğŸ”„ **REMOVIDO DA FILA!**

ğŸ® **Respawn:**
â”£â” **${respawnInfo.nome}** (${codigo.toUpperCase()})
â”—â” **Tier:** ${respawnInfo.tier}

âœ… **VocÃª foi removido da fila de espera!**
ğŸ’¡ Use **!next ${codigo} [tempo]** para entrar na fila novamente (se houver claimed ativo).`;
                  } catch (error2: any) {
                    resposta = `âŒ **NÃ£o Encontrado**\n\nğŸ” VocÃª nÃ£o estÃ¡ no claimed nem na fila do cÃ³digo **${codigo.toUpperCase()}**\n\nğŸ’¡ Use **!respinfo ${codigo}** para ver a fila atual.`;
                  }
                }
              } catch (error) {
                resposta = `âŒ Erro ao processar comando. Tente novamente.`;
              }
            } else {
              resposta = "â“ Uso: !leave [cÃ³digo]\nExemplo: !leave f4";
            }
            break;
          }

          if (mensagem.startsWith("!next ")) {
            const parametros = mensagem.replace("!next ", "").trim().split(" ");
            const codigo = parametros[0];
            const tempoStr = parametros[1] || "2:30"; // Tempo padrÃ£o 2:30
            
            if (codigo) {
              // NOVA VALIDAÃ‡ÃƒO: Verificar se hÃ¡ claimed ativo no cÃ³digo
              let temClaimedAtivo = false;
              for (const [timerKey, timer] of this.timers) {
                if (timer.codigo.toLowerCase() === codigo.toLowerCase()) {
                  temClaimedAtivo = true;
                  break;
                }
              }
              
              if (!temClaimedAtivo) {
                const respawnInfo = this.obterInfoRespawn(codigo);
                resposta = `ğŸš« **RESPAWN DISPONÃVEL**

ğŸ® **Respawn:** ${respawnInfo.nome} (${codigo.toUpperCase()})
ğŸ·ï¸ **Tier:** ${respawnInfo.tier}

âŒ **NÃ£o Ã© possÃ­vel entrar na fila**
O respawn estÃ¡ livre no momento!

âœ… **Use diretamente:** **!resp ${codigo} [tempo]**
ğŸ’¡ O comando !next sÃ³ funciona quando hÃ¡ um claimed ativo.

ğŸ¯ **Exemplo:** !resp ${codigo} 2:00`;
                break;
              }
              
              // Validar e converter tempo
              const tempoValidado = this.validarTempo(tempoStr);
              if (tempoValidado.valido) {
                try {
                  await this.adicionarNaFilaNext(nomeUsuario, codigo, identificadorUnico, tempoValidado.minutos);
                  const posicao = this.nextQueues.get(codigo)?.length || 0;
                  const respawnInfo = this.obterInfoRespawn(codigo);
                  
                  resposta = `ğŸ”„ **ADICIONADO Ã€ FILA!**

ğŸ® **Respawn Selecionado:**
â”£â” **${respawnInfo.nome}** (${codigo.toUpperCase()})
â”—â” **Tier:** ${respawnInfo.tier}

ğŸ“Š **Status da Fila:**
â”£â” **Sua PosiÃ§Ã£o:** #${posicao}
â”—â” **Tempo Desejado:** ${tempoValidado.formatado}

âœ¨ **Sistema AutomÃ¡tico Ativo!**
Quando for sua vez, vocÃª receberÃ¡ um poke automaticamente.
ğŸ’¡ Use **!resp ${codigo}** para aceitar quando chegue sua vez!`;
                } catch (error: any) {
                  resposta = `âŒ ${error.message}`;
                }
              } else {
                resposta = `âŒ Tempo invÃ¡lido! Use o formato HH:MM (mÃ¡ximo 2:30)\nExemplo: !next f4 1:30`;
              }
            } else {
              resposta = "â“ Uso: !next [cÃ³digo] [tempo]\nExemplos:\nâ€¢ !next f4 (tempo padrÃ£o 2:30)\nâ€¢ !next f4 1:30";
            }
            break;
          }

          if (mensagem.startsWith("!respinfo ")) {
            const codigo = mensagem.replace("!respinfo ", "").trim();
            if (codigo) {
              resposta = this.obterFilaRespawn(codigo);
            } else {
              resposta = "â“ Uso: !respinfo [cÃ³digo]\nExemplo: !respinfo f4";
            }
            break;
          }

          if (mensagem.startsWith("!")) {
            resposta = `â“ Comando nÃ£o reconhecido: "${mensagem}"
Digite !help para ver os comandos disponÃ­veis.`;
          } else {
            resposta = `ğŸ‘‹ OlÃ¡! Recebi sua mensagem: "${evento.msg}"
Digite !help para ver os comandos disponÃ­veis.`;
          }
      }

      // Enviar resposta
      if (resposta) {
        if (evento.targetmode === 2) {
          // Mensagem de canal - responder no mesmo canal
          await this.enviarMensagemCanal(evento.targetid, resposta, remetente);
        } else if (evento.targetmode === 1) {
          // Mensagem privada - responder por privado
          const clientId = evento.invokerid?.toString() || evento.clid?.toString();
          if (clientId) {
            await this.enviarMensagemPrivada(clientId, resposta);
          } else {
            console.error("âŒ NÃ£o foi possÃ­vel identificar o ID do cliente para resposta");
          }
        } else {
          // Mensagem de servidor - responder no canal atual do remetente
          await this.enviarMensagemServidor(resposta, remetente);
        }
      }

    } catch (error) {
      console.error("âŒ Erro ao processar mensagem:", error);
    }
  }

  private async enviarMensagemPrivada(clientId: string, mensagem: string): Promise<void> {
    try {
      console.log(`ğŸ”„ Tentando enviar mensagem privada para cliente ID: ${clientId}`);
      
      // Verificar se o clientId Ã© vÃ¡lido
      if (!clientId || clientId === "undefined") {
        console.error("âŒ ID do cliente invÃ¡lido:", clientId);
        return;
      }

      // Enviar mensagem privada (targetmode 1)
      await this.teamspeak!.sendTextMessage(clientId, 1, mensagem);
      console.log(`ğŸ“¤ Mensagem privada enviada para cliente ${clientId}: "${mensagem.substring(0, 50)}..."`);
    } catch (error: any) {
      console.error("âŒ Erro ao enviar mensagem privada:", error.msg || error.message);
      console.error("   Client ID:", clientId);
      console.error("   Mensagem:", mensagem.substring(0, 100));
    }
  }

  private async enviarMensagemCanal(channelId: string, mensagem: string, remetente: string): Promise<void> {
    try {
      console.log(`ğŸ”„ Tentando enviar mensagem no canal ID: ${channelId}`);
      
      // Verificar se o channelId Ã© vÃ¡lido
      if (!channelId || channelId === "undefined") {
        console.error("âŒ ID do canal invÃ¡lido:", channelId);
        return;
      }

      // Adicionar menÃ§Ã£o ao remetente na resposta
      const mensagemComMencao = `@${remetente}: ${mensagem}`;

      // Enviar mensagem no canal (targetmode 2)
      await this.teamspeak!.sendTextMessage(channelId, 2, mensagemComMencao);
      console.log(`ğŸ“¤ Mensagem enviada no canal ${channelId}: "${mensagemComMencao.substring(0, 50)}..."`);
    } catch (error: any) {
      console.error("âŒ Erro ao enviar mensagem no canal:", error.msg || error.message);
      console.error("   Channel ID:", channelId);
      console.error("   Mensagem:", mensagem.substring(0, 100));
    }
  }

  private async enviarMensagemServidor(mensagem: string, remetente: string): Promise<void> {
    try {
      console.log(`ğŸ”„ Tentando enviar mensagem no servidor`);
      
      // Adicionar menÃ§Ã£o ao remetente na resposta
      const mensagemComMencao = `@${remetente}: ${mensagem}`;

      // Enviar mensagem no servidor (targetmode 3 = servidor virtual)
      await this.teamspeak!.sendTextMessage("0", 3 as any, mensagemComMencao);
      console.log(`ğŸ“¤ Mensagem enviada no servidor: "${mensagemComMencao.substring(0, 50)}..."`);
    } catch (error: any) {
      console.error("âŒ Erro ao enviar mensagem no servidor:", error.msg || error.message);
      console.error("   Mensagem:", mensagem.substring(0, 100));
    }
  }

  private async enviarBoasVindas(evento: any): Promise<void> {
    try {
      // Aguardar um pouco para o cliente se conectar completamente
      setTimeout(async () => {
        const mensagemBoasVindas = `ğŸ‘‹ Bem-vindo ao servidor!

ğŸ¤– Eu sou o ${this.config.nickname}, seu bot assistente.
ğŸ’¬ Envie-me uma mensagem privada com !help para ver os comandos disponÃ­veis.

ğŸ® Comandos Ãºteis:
â€¢ !help - Lista de comandos
â€¢ !info - InformaÃ§Ãµes do servidor  
â€¢ !ping - Testar bot

Divirta-se no servidor! ï¿½`;

        try {
          // Usar o ID correto do evento
          const clientId = evento.clid || evento.clientId;
          if (clientId) {
            await this.enviarMensagemPrivada(clientId.toString(), mensagemBoasVindas);
          }
        } catch (error) {
          console.log("âš ï¸ NÃ£o foi possÃ­vel enviar boas-vindas:", (error as any).msg);
        }
      }, 3000); // Aguardar 3 segundos para conexÃ£o estabilizar

    } catch (error) {
      console.log("âš ï¸ Erro nas boas-vindas:", error);
    }
  }

  async listarClientes(): Promise<void> {
    if (!this.teamspeak) return;

    try {
      const clients = await this.teamspeak.clientList();
      console.log(`ğŸ‘¥ Clientes conectados (${clients.length}):`);
      clients.forEach(client => {
        console.log(`   â€¢ ID: ${client.clid}`);
      });
    } catch (error) {
      console.error("âŒ Erro ao listar clientes:", error);
    }
  }

  async disconnect(): Promise<void> {
    // Salvar timers antes de desconectar
    if (this.timers.size > 0) {
      console.log(`ğŸ’¾ Salvando ${this.timers.size} timers ativos antes da desconexÃ£o...`);
      this.salvarTimers();
    }

    // Salvar filas antes de desconectar
    if (this.nextQueues.size > 0 || this.nextTimeouts.size > 0) {
      console.log(`ğŸ’¾ Salvando filas e timeouts antes da desconexÃ£o...`);
      this.salvarFilas();
    }

    // Limpar todos os timers ativos
    this.timers.forEach((timer, key) => {
      clearInterval(timer.intervalId);
      console.log(`â° Timer pausado: ${timer.userName} - ${timer.codigo} (${timer.tempoRestante} min restantes)`);
    });
    this.timers.clear();

    // Limpar todos os timeouts ativos
    this.nextTimeouts.forEach((timeout, key) => {
      clearTimeout(timeout.timeoutId);
      console.log(`â° Timeout pausado: ${timeout.userName} - ${timeout.codigo}`);
    });
    this.nextTimeouts.clear();
    
    if (this.teamspeak) {
      await this.teamspeak.quit();
      console.log("ğŸ”Œ Bot desconectado - timers e filas preservados");
    }
  }

  async getStatus(): Promise<void> {
    if (!this.teamspeak) {
      console.log("âŒ Bot nÃ£o estÃ¡ conectado!");
      return;
    }

    try {
      const whoami = await this.teamspeak.whoami();
      console.log(`âœ… Bot ativo - ID: ${whoami.clientId} | Servidor: ${whoami.virtualserverId}`);
    } catch (error) {
      console.error("âŒ Erro ao verificar status:", error);
    }
  }

  async verificarLocalizacao(): Promise<void> {
    if (!this.teamspeak) {
      console.log("âŒ Bot nÃ£o estÃ¡ conectado!");
      return;
    }

    try {
      const whoami = await this.teamspeak.whoami();
      const channelId = whoami.channelId || 'nÃ£o identificado';
      console.log(`ğŸ“ ConfirmaÃ§Ã£o: Bot estÃ¡ no Canal ID ${channelId}`);
      
      if (channelId !== 'nÃ£o identificado') {
        // Obter nome do canal atual
        try {
          const channels = await this.teamspeak.channelList();
          const currentChannel = channels?.find((ch: any) => ch.cid?.toString() === channelId?.toString());
          if (currentChannel) {
            console.log(`ğŸ·ï¸ Nome do canal: "${currentChannel.name}"`);
            
            // Confirmar se Ã© o Default Channel
            if (currentChannel.name === "Default Channel") {
              console.log(`ğŸ¯ âœ… Bot confirmado no Default Channel!`);
            }
          } else {
            console.log(`âš ï¸ Canal ID ${channelId} nÃ£o encontrado na lista de canais`);
          }
        } catch (channelError) {
          console.log("âš ï¸ NÃ£o foi possÃ­vel obter informaÃ§Ãµes dos canais");
        }
      }
    } catch (error) {
      console.log("âš ï¸ NÃ£o foi possÃ­vel verificar localizaÃ§Ã£o do bot:", error);
    }
  }

  private validarTempo(tempoStr: string): { valido: boolean, minutos: number, formatado: string } {
    // Regex para validar formato HH:MM ou H:MM
    const regex = /^(\d{1,2}):(\d{2})$/;
    const match = tempoStr.match(regex);
    
    if (!match) {
      return { valido: false, minutos: 0, formatado: "" };
    }
    
    const horas = parseInt(match[1]);
    const minutosInput = parseInt(match[2]);
    
    // ValidaÃ§Ãµes
    if (horas < 0 || horas > 2 || minutosInput < 0 || minutosInput >= 60) {
      return { valido: false, minutos: 0, formatado: "" };
    }
    
    // Verificar se nÃ£o excede 2:30 (2 horas e 30 minutos = 150 minutos)
    const totalMinutos = (horas * 60) + minutosInput;
    if (totalMinutos > 150) { // 2:30 = 150 minutos
      return { valido: false, minutos: 0, formatado: "" };
    }
    
    const formatado = `${horas}:${minutosInput.toString().padStart(2, '0')}`;
    
    return { valido: true, minutos: totalMinutos, formatado };
  }

  private formatarTempoRestante(minutos: number): string {
    const horas = Math.floor(minutos / 60);
    const mins = minutos % 60;
    
    return `[${horas.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}]`;
  }

  private obterInfoRespawn(codigo: string): RespawnInfo {
    return this.respawns.get(codigo.toLowerCase()) || { nome: `Respawn ${codigo.toUpperCase()}`, tier: 'Tier ?' };
  }

  async adicionarClaimed(nomeUsuario: string, codigo: string, userId: string): Promise<void> {
    if (!this.teamspeak) {
      throw new Error("Bot nÃ£o estÃ¡ conectado!");
    }

    try {
      console.log(`ğŸ”„ Adicionando ${nomeUsuario} (ID: ${userId}) ao cÃ³digo ${codigo} no canal Claimeds...`);
      
      // ID do canal Claimeds Ã© 2 (descoberto anteriormente)
      const claimedChannelId = "2";
      
      // Obter descriÃ§Ã£o atual do canal Claimeds
      const channelInfo = await this.teamspeak.channelInfo(claimedChannelId);
      let descricaoAtual = channelInfo.channelDescription || "";
      
      // Criar linha de informaÃ§Ã£o para o usuÃ¡rio
      const novaLinha = `ğŸ‘¤ ${nomeUsuario} (ID: ${userId}) estÃ¡ no ${codigo.toUpperCase()}`;
      
      // Verificar se o usuÃ¡rio jÃ¡ estÃ¡ listado neste cÃ³digo
      const linhaExistente = descricaoAtual
        .split('\n')
        .find(linha => linha.includes(`(ID: ${userId})`) && linha.includes(codigo.toUpperCase()));
      
      if (linhaExistente) {
        console.log(`âš ï¸ UsuÃ¡rio ${nomeUsuario} jÃ¡ estÃ¡ registrado no cÃ³digo ${codigo}`);
        return;
      }
      
      // Adicionar nova linha
      let novaDescricao = descricaoAtual;
      if (novaDescricao && !novaDescricao.endsWith('\n')) {
        novaDescricao += '\n';
      }
      novaDescricao += novaLinha;
      
      // Atualizar descriÃ§Ã£o do canal
      await this.teamspeak.channelEdit(claimedChannelId, {
        channelDescription: novaDescricao
      });
      
      console.log(`âœ… ${nomeUsuario} adicionado ao cÃ³digo ${codigo} no canal Claimeds!`);
      
    } catch (error: any) {
      console.error("âŒ Erro ao adicionar claimed:", error.msg || error.message);
      throw error;
    }
  }

  async adicionarClaimedComTimer(nomeUsuario: string, codigo: string, userId: string, tempoMinutos: number): Promise<void> {
    if (!this.teamspeak) {
      throw new Error("Bot nÃ£o estÃ¡ conectado!");
    }

    try {
      // Parar timer existente se houver
      const timerKey = `${userId}-${codigo}`;
      if (this.timers.has(timerKey)) {
        clearInterval(this.timers.get(timerKey)!.intervalId);
        this.timers.delete(timerKey);
      }

      // Obter informaÃ§Ãµes do respawn
      const respawnInfo = this.obterInfoRespawn(codigo);
      const iniciadoEm = Date.now();

      console.log(`â° Iniciando timer de ${tempoMinutos} minutos para ${nomeUsuario} no cÃ³digo ${codigo} (${respawnInfo.nome})`);

      // Adicionar entrada inicial no canal (jÃ¡ atualiza a visualizaÃ§Ã£o)
      await this.atualizarClaimedComTempo(nomeUsuario, codigo, userId, tempoMinutos, respawnInfo);

      // Criar timer (atualiza a cada minuto)
      const intervalId = setInterval(async () => {
        const timer = this.timers.get(timerKey);
        if (!timer) {
          console.log(`âš ï¸ Timer recuperado ${timerKey} nÃ£o encontrado, parando intervalo`);
          clearInterval(intervalId);
          return;
        }

        timer.tempoRestante--;
        console.log(`â° Timer atualizado: ${timer.userName} (${timer.codigo}) - ${timer.tempoRestante} min restantes`);

        if (timer.tempoRestante <= 0) {
          // Tempo esgotado - limpar interval primeiro antes de chamar removerClaimedAutomatico
          clearInterval(intervalId);
          this.timers.delete(timerKey);
          this.salvarTimers(); // Salvar apÃ³s remoÃ§Ã£o
          console.log(`â° Timer expirado para ${nomeUsuario} no cÃ³digo ${codigo}`);
          
          // Agora chamar removerClaimedAutomatico sem conflito de timer
          await this.removerClaimedAutomatico(nomeUsuario, codigo, userId);
        } else {
          // Atualizar tempo restante a cada minuto
          const respawnInfo = this.obterInfoRespawn(timer.codigo);
          await this.atualizarClaimedComTempo(timer.userName, timer.codigo, timer.userId, timer.tempoRestante, respawnInfo);
          this.salvarTimers(); // Salvar apÃ³s cada atualizaÃ§Ã£o
          console.log(`ğŸ“Š Canal atualizado para ${timer.userName} (${timer.codigo}) - ${timer.tempoRestante} min restantes`);
        }
      }, 60000); // Atualizar a cada minuto (60000ms)

      // Armazenar o timer
      this.timers.set(timerKey, {
        userId,
        userName: nomeUsuario,
        codigo,
        nomeRespawn: respawnInfo.nome,
        tier: respawnInfo.tier,
        tempoRestante: tempoMinutos,
        intervalId,
        iniciadoEm
      });

      // Salvar timers apÃ³s criaÃ§Ã£o
      this.salvarTimers();

    } catch (error: any) {
      console.error("âŒ Erro ao adicionar claimed com timer:", error.msg || error.message);
      throw error;
    }
  }

  private async atualizarClaimedComTempo(nomeUsuario: string, codigo: string, userId: string, tempoRestante: number, respawnInfo: RespawnInfo): Promise<void> {
    if (!this.teamspeak) return;

    try {
      const claimedChannelId = "2";
      
      // Obter descriÃ§Ã£o atual do canal Claimeds
      const channelInfo = await this.teamspeak.channelInfo(claimedChannelId);
      let descricaoAtual = channelInfo.channelDescription || "";
      
      // Separar a imagem permanente dos timers ativos
      const descricaoBase = this.obterDescricaoBaseClaimeds();
      
      // Extrair apenas as linhas de timers (ignorar a imagem permanente)
      let linhasTimers: string[] = [];
      if (descricaoAtual.includes('â° Timers ativos abaixo:')) {
        const partesDescricao = descricaoAtual.split('â° Timers ativos abaixo:\n');
        if (partesDescricao.length > 1) {
          linhasTimers = partesDescricao[1].split('\n').filter(linha => linha.trim() !== '');
        }
      }
      
      // Remover entrada existente do usuÃ¡rio para este cÃ³digo (se houver)
      const linhasFiltradas = linhasTimers.filter(linha => {
        const contemUsuario = linha.includes(`client://${userId}/${nomeUsuario}`);
        const contemCodigo = linha.startsWith(`${codigo.toLowerCase()} -`);
        return !(contemUsuario && contemCodigo);
      });
      
      // Criar nova linha com formataÃ§Ã£o BBCode
      const tempoFormatado = this.formatarTempoRestante(tempoRestante);
      const tempoComCor = `[color=#FF6600][b]${tempoFormatado}[/b][/color]`; // Laranja escuro e negrito
      const respawnFormatado = `[b]${respawnInfo.nome} (${respawnInfo.tier})[/b]`; // Negrito com cor padrÃ£o
      const usuarioFormatado = `[color=#0066CC][url=client://${userId}/${nomeUsuario}]${nomeUsuario}[/url][/color]`; // Azul com link clicÃ¡vel
      
      let novaLinha = `${codigo.toLowerCase()} - ${tempoComCor} ${respawnFormatado}: ${usuarioFormatado}`;
      
      // Verificar se hÃ¡ prÃ³ximo usuÃ¡rio na fila para adicionar "| Next: Nome" tambÃ©m com link
      const filaAtual = this.nextQueues.get(codigo.toLowerCase());
      if (filaAtual && filaAtual.length > 0) {
        const proximoUsuario = filaAtual[0];
        const proximoUsuarioFormatado = `[color=#0066CC][url=client://${proximoUsuario.userId}/${proximoUsuario.userName}]${proximoUsuario.userName}[/url][/color]`;
        novaLinha += ` | Next: ${proximoUsuarioFormatado}`;
      }
      
      // Adicionar nova linha
      linhasFiltradas.push(novaLinha);
      
      // Construir descriÃ§Ã£o final: imagem + timers
      let novaDescricao = descricaoBase;
      if (linhasFiltradas.length > 0) {
        novaDescricao += linhasFiltradas.join('\n');
      }
      // NÃ£o adicionar mensagem "nenhum claimed ativo" quando hÃ¡ timers ativos
      
      // Atualizar descriÃ§Ã£o do canal
      await this.teamspeak.channelEdit(claimedChannelId, {
        channelDescription: novaDescricao
      });
      
    } catch (error: any) {
      console.error("âŒ Erro ao atualizar claimed com tempo:", error.msg || error.message);
    }
  }

  private async removerClaimedAutomatico(nomeUsuario: string, codigo: string, userId: string): Promise<void> {
    try {
      // Apenas remover do canal Claimeds (o timer jÃ¡ foi removido antes de chamar este mÃ©todo)
      await this.atualizarTodosTimersNoCanal();
      console.log(`â° ${nomeUsuario} removido automaticamente do cÃ³digo ${codigo} (tempo esgotado)`);
      
      // Enviar poke informando que o claimed expirou
      try {
        // Buscar ID numÃ©rico real do cliente
        let clienteId = userId;
        try {
          const clients = await this.teamspeak!.clientList();
          const cliente = clients.find((c: any) => c.nickname === nomeUsuario);
          if (cliente && cliente.clid) {
            clienteId = cliente.clid.toString();
            console.log(`ğŸ” ID real do cliente ${nomeUsuario}: ${clienteId}`);
          }
        } catch (error) {
          console.log(`âš ï¸ NÃ£o foi possÃ­vel buscar ID real do cliente ${nomeUsuario}`);
        }

        const respawnInfo = this.obterInfoRespawn(codigo);
        await this.enviarPoke(clienteId, `â° [color=#FF0000]CLAIMED EXPIRADO! Seu tempo no respawn ${respawnInfo.nome} (${codigo.toUpperCase()}) acabou!`);
        console.log(`âœ… Poke de expiraÃ§Ã£o enviado para ${nomeUsuario}`);
        
        // TambÃ©m enviar mensagem privada com detalhes
        const mensagemExpiracao = `â° **CLAIMED EXPIRADO!**

Seu tempo no respawn **${respawnInfo.nome}** (${codigo.toUpperCase()}) acabou!

ğŸ¯ Status: **Finalizado**
â­ Obrigado por usar o sistema de claimeds!

ğŸ’¡ Use **!resp ${codigo.toLowerCase()} [tempo]** para clamar novamente se estiver livre.[/color]`;

        await this.enviarMensagemPrivada(clienteId, mensagemExpiracao);
        
      } catch (error) {
        console.log(`âš ï¸ NÃ£o foi possÃ­vel enviar notificaÃ§Ã£o de expiraÃ§Ã£o para ${nomeUsuario}`);
      }
      
      // Verificar se hÃ¡ prÃ³ximo usuÃ¡rio na fila para assumir automaticamente
      const filaAtual = this.nextQueues.get(codigo.toLowerCase());
      if (filaAtual && filaAtual.length > 0) {
        const proximoUsuario = filaAtual[0];
        console.log(`ï¿½ Transferindo automaticamente cÃ³digo ${codigo} para ${proximoUsuario.userName} por ${proximoUsuario.tempoDesejado} minutos`);
        
        // Buscar ID numÃ©rico real do cliente para enviar notificaÃ§Ã£o
        let clienteId = proximoUsuario.userId;
        try {
          const clients = await this.teamspeak!.clientList();
          const cliente = clients.find((c: any) => c.nickname === proximoUsuario.userName);
          if (cliente && cliente.clid) {
            clienteId = cliente.clid.toString();
            console.log(`ğŸ” ID real do cliente ${proximoUsuario.userName}: ${clienteId}`);
          }
        } catch (error) {
          console.log(`âš ï¸ NÃ£o foi possÃ­vel buscar ID real do cliente ${proximoUsuario.userName}`);
        }
        
        try {
          // Remover da fila primeiro
          await this.removerDaFilaNext(proximoUsuario.userName, proximoUsuario.codigo, proximoUsuario.userId);
          
          // Criar o claimed automaticamente com o tempo escolhido pelo usuÃ¡rio
          await this.adicionarClaimedComTimer(proximoUsuario.userName, proximoUsuario.codigo, proximoUsuario.userId, proximoUsuario.tempoDesejado);
          
          // Enviar notificaÃ§Ã£o de que assumiu automaticamente
          try {
            const respawnInfo = this.obterInfoRespawn(codigo);
            const tempoFormatado = this.formatarTempoRestante(proximoUsuario.tempoDesejado);
            await this.enviarPoke(clienteId, `ğŸ¯ CLAIMED ASSUMIDO! VocÃª assumiu automaticamente o respawn ${respawnInfo.nome} (${codigo.toUpperCase()}) por ${tempoFormatado}!`);
            console.log(`âœ… NotificaÃ§Ã£o enviada para ${proximoUsuario.userName}`);
            
            // TambÃ©m enviar mensagem privada com detalhes melhorada
            const mensagem = `ğŸ¯ **CLAIMED ASSUMIDO AUTOMATICAMENTE!**

ğŸ® **Respawn Transferido:**
â”£â” **${respawnInfo.nome}** (${codigo.toUpperCase()})
â”—â” **Tier:** ${respawnInfo.tier}

â° **Timer Configurado:**
â”£â” **Tempo:** ${tempoFormatado}
â”—â” **Status:** Ativo e contando automaticamente

âœ¨ **Sistema AutomÃ¡tico Ativo!**
Seu claimed jÃ¡ estÃ¡ funcionando perfeitamente!

ğŸ’¡ Use **!leave ${codigo.toLowerCase()}** para sair quando quiser.`;

            await this.enviarMensagemPrivada(clienteId, mensagem);
            
          } catch (error) {
            console.log(`âš ï¸ NÃ£o foi possÃ­vel enviar notificaÃ§Ã£o para ${proximoUsuario.userName}`);
          }
          
          console.log(`âœ… ${proximoUsuario.userName} assumiu automaticamente o cÃ³digo ${codigo} por ${proximoUsuario.tempoDesejado} minutos`);
          
        } catch (error) {
          console.error(`âŒ Erro ao transferir claimed automaticamente para ${proximoUsuario.userName}:`, error);
          // Se falhou a transferÃªncia automÃ¡tica, voltar ao sistema de poke
          try {
            await this.enviarPoke(clienteId, `ğŸ¯ RESPAWN LIVRE! O respawn ${this.obterInfoRespawn(codigo).nome} (${codigo.toUpperCase()}) estÃ¡ disponÃ­vel para caÃ§ar!`);
            await this.processarProximoDaFila(codigo);
          } catch (fallbackError) {
            console.log(`âš ï¸ Erro no fallback para ${proximoUsuario.userName}`);
          }
        }
      } else {
        console.log(`ğŸ“­ Nenhum usuÃ¡rio na fila do cÃ³digo ${codigo} - respawn fica livre`);
      }
      
    } catch (error) {
      console.error("âŒ Erro ao remover automaticamente:", error);
    }
  }

  async removerClaimed(nomeUsuario: string, codigo: string, userId: string): Promise<void> {
    if (!this.teamspeak) {
      throw new Error("Bot nÃ£o estÃ¡ conectado!");
    }

    try {
      console.log(`ğŸ”„ Removendo ${nomeUsuario} (ID: ${userId}) do cÃ³digo ${codigo} no canal Claimeds...`);
      
      // Parar timer se existir
      const timerKey = `${userId}-${codigo}`;
      if (this.timers.has(timerKey)) {
        clearInterval(this.timers.get(timerKey)!.intervalId);
        this.timers.delete(timerKey);
        this.salvarTimers(); // Salvar apÃ³s remoÃ§Ã£o
        console.log(`â° Timer cancelado para ${nomeUsuario} no cÃ³digo ${codigo}`);
      }
      
      // Atualizar canal com todos os timers restantes (usa a lÃ³gica padrÃ£o)
      await this.atualizarTodosTimersNoCanal();
      
      console.log(`âœ… ${nomeUsuario} removido do cÃ³digo ${codigo} no canal Claimeds!`);
      
    } catch (error: any) {
      console.error("âŒ Erro ao remover claimed:", error.msg || error.message);
      throw error;
    }
  }

  // MÃ©todo para salvar cache da API Tibia em arquivo
  private async salvarCacheTibia(): Promise<void> {
    try {
      const cacheData = {
        version: '1.0',
        timestamp: this.ultimaAtualizacaoTibia,
        membrosOnline: this.membrosOnlineTibia,
        savedAt: new Date().toISOString()
      };
      
      fs.writeFileSync(this.tibiaCacheFilePath, JSON.stringify(cacheData, null, 2));
      console.log(`ğŸ’¾ Cache Tibia salvo: ${this.membrosOnlineTibia.length} membros online`);
    } catch (error) {
      console.error("âŒ Erro ao salvar cache Tibia:", error);
    }
  }

  // MÃ©todo para carregar cache da API Tibia do arquivo
  private async carregarCacheTibia(): Promise<void> {
    try {
      if (!fs.existsSync(this.tibiaCacheFilePath)) {
        console.log("ğŸ“‚ Nenhum cache Tibia encontrado");
        return;
      }

      const dados = fs.readFileSync(this.tibiaCacheFilePath, 'utf8');
      const cacheData = JSON.parse(dados);
      
      if (cacheData.version && cacheData.timestamp && cacheData.membrosOnline) {
        this.ultimaAtualizacaoTibia = cacheData.timestamp;
        this.membrosOnlineTibia = cacheData.membrosOnline;
        
        const idadeCache = Math.floor((Date.now() - this.ultimaAtualizacaoTibia) / (1000 * 60));
        console.log(`ğŸ“‚ Cache Tibia carregado: ${this.membrosOnlineTibia.length} membros (${idadeCache} min atrÃ¡s)`);
      } else {
        console.log("âš ï¸ Cache Tibia invÃ¡lido, ignorando");
      }
    } catch (error) {
      console.error("âŒ Erro ao carregar cache Tibia:", error);
    }
  }

  // ...existing code...
}

// FunÃ§Ã£o para carregar configuraÃ§Ã£o
function loadClientConfig(): BotClientConfig {
  try {
    const configData = require('../config.json');
    return {
      host: configData.teamspeak.host,
      serverport: configData.teamspeak.serverport,
      queryport: configData.teamspeak.queryport,
      username: configData.teamspeak.username,
      password: configData.teamspeak.password,
      nickname: configData.teamspeak.nickname,
      protocol: configData.teamspeak.protocol as "raw" | "ssh",
      channelId: configData.teamspeak.channelId || undefined
    };
  } catch (error) {
    console.error("âŒ Erro ao carregar config.json:", error);
    process.exit(1);
  }
}

// FunÃ§Ã£o principal para o bot cliente
async function mainClient() {
  const config = loadClientConfig();
  const bot = new TS3ClientBot(config);

  // Lidar com sinais de interrupÃ§Ã£o
  process.on('SIGINT', async () => {
    console.log("\nğŸ›‘ Interrompendo bot cliente...");
    await bot.disconnect();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    console.log("\nğŸ›‘ Terminando bot cliente...");
    await bot.disconnect();
    process.exit(0);
  });

  try {
    await bot.connect();
    
    // Mostrar status periodicamente
    setInterval(async () => {
      await bot.getStatus();
      await bot.listarClientes();
      console.log("---");
    }, 60000); // A cada 60 segundos

      console.log(`ğŸ¤– Bot cliente ${config.nickname} estÃ¡ ativo!`);
    console.log("ğŸ’¬ UsuÃ¡rios podem enviar mensagens privadas para interagir!");
    console.log("ğŸ“ Digite Ctrl+C para parar o bot.");
    
    // Verificar localizaÃ§Ã£o final do bot
    setTimeout(async () => {
      await bot.verificarLocalizacao();
    }, 2000);  } catch (error) {
    console.error("ğŸ’¥ Falha ao iniciar o bot cliente:", error);
    process.exit(1);
  }
}

// Executar se este arquivo for chamado diretamente
if (require.main === module) {
  mainClient();
}

export { TS3ClientBot, BotClientConfig, loadClientConfig };
